Understanding Git Branches (Most Important Topic)

Alright, now let‚Äôs move to one of the most important concepts in Git,
and that is branches.

Now, if I open our repository on GitHub,
you will notice there is an option called Branch.

And if you remember, even inside our local project folder,
when we run the command:

git branch

Git will list all the branches available in that repository.

Right now, we have only one branch,
and that branch is called main.

----

What is the Main Branch?

Now let‚Äôs understand this clearly.

By default, when we create a Git repository,
Git creates a branch called main.

The main branch is very special.

Why?
Because main branch holds the final, production-ready code.

This is the code that:

gets deployed on a server
runs as a live website or application
is considered stable and complete

So whenever users open your website or app,
they are actually using the code from the main branch.

----

Working Alone vs Working in a Team

Now suppose I am working alone on a small project.

In that case, I can:

make changes directly on the main branch
fix bugs on the main branch
add features on the main branch
push everything to GitHub

And that‚Äôs totally fine.

But problems start when we work on a big project
or when multiple developers are involved.

----

Bug Fix Scenario (Very Common in Real Projects)

Let‚Äôs say I am here on the main branch.

Everything is working fine.

Suddenly, I discover a bug.

Now instead of fixing it directly on main,
I do this:

I create a new branch from the current point
I switch to that branch
I do all bug-related changes there
I make multiple small commits
I test everything properly

Once I‚Äôm confident that the bug is fixed,
I merge that branch back into main.

So what happens?

Main branch stays clean
and only receives final, tested code.

----

Long Feature Development Problem

Now let‚Äôs talk about a very realistic problem.

Suppose you are working on a big feature
that will take 15 to 30 days to complete.

Now answer this honestly:

‚ùì Should you commit half-done code every day on the main branch?

No. Absolutely not.

Because:
the feature is incomplete
the code is unstable
other teammates might pull it
production may break

Now another option is:
‚ÄúOkay, I‚Äôll just keep the code on my laptop.‚Äù

But that is also risky.

What if:
your system crashes?
hard disk fails?
files get corrupted?

Your 30 days of work is gone.

----

Correct Way: Feature Branch

So what do we do?

We create a new branch specifically for that feature.
Now on that branch:

Day 1 ‚Üí commit
Day 2 ‚Üí commit
Day 3 ‚Üí commit
‚Ä¶
Day 30 ‚Üí feature completed

All these commits are safe,
pushed to GitHub,
but not affecting the main branch.

Once the feature is:
completed
tested
reviewed

We merge it into main.
----

E-commerce Website Example

Let‚Äôs take a practical example.

Imagine you are working on an e-commerce website.

On the main branch:

homepage is ready
product listing is ready
Now you want to build a search feature.

What do you do?
You create a branch called:

search-feature

On this branch:

you design the UI
you write search logic
you optimize performance
you fix edge cases

Once everything works perfectly,
you merge this branch into main.

Main branch now gets:
‚úîÔ∏è complete search feature
‚ùå no half-baked commits

----

Multiple Developers, Multiple Branches

Now imagine a team scenario.

You are working on search
One teammate is working on product page
Another teammate is working on image optimization
Someone else is working on testing

Each person creates their own branch.
They work independently.
No one disturbs the main branch.

Once their work is complete:

they merge their branch
main branch keeps improving cleanly

---

Real-World Example: Big Companies

This is not just theory.

If you open any real-world open-source project,
you will see many branches.

There will be branches for:

new features
bug fixes
testing
experiments
version upgrades

Even the biggest companies follow this:

startups
mid-size companies
large tech giants

Branches are not optional.
They are mandatory for professional development.

---------------------------------------

Practical Walkthrough

So till now, we have been working only with one branch,
and that branch is our main branch.

Now it‚Äôs time to do something practical.

We‚Äôre not just going to talk theory ‚Äî
we are actually going to create branches,
switch between them,
make commits,
and finally merge everything back.

So let‚Äôs start slowly.
-----
Creating a Branch

We use the command:

git branch <branch-name>

That‚Äôs it.

Now, before creating branches, let‚Äôs understand naming conventions.

-----

Branch Naming Convention (Very Important)

In real projects, we don‚Äôt randomly name branches.

We usually follow patterns like:

feature-<feature-name>
fix-<bug-name>
test-<experiment-name>

So:

If you‚Äôre working on a feature ‚Üí use feature-
If you‚Äôre fixing a bug ‚Üí use fix-
If you‚Äôre testing something ‚Üí use test-

This makes branches readable and professional.

-----

Creating a Feature Branch

Now suppose I‚Äôm working on a button feature.

git branch feature-button

Now pause here and understand this carefully.

This command creates the branch,
but it does NOT switch to it.

Right now, we still remain on the main branch.

-----

Checking Available Branches

To confirm that, I run:

git branch
You‚Äôll see:

main
feature-button
And the star (*) will be next to main.
That means we are still on main branch.

-----

Switching to a Branch

Now if I want to start working on feature-button,
I must switch to it.

So I run:
git checkout feature-button

Now Git tells me:

Switched to branch 'feature-button'

If I run git branch again,
you‚Äôll see the star is now next to feature-button.

That means:

All commits from now on will go into feature-button


-----

Think of it like this:

Main branch has its own timeline
Feature branch is created from a specific commit
From that point, both branches move independently

Your editor and Git know exactly
which branch you are working on.

-----

Making Changes in Feature Branch

Now I‚Äôm inside feature-button.
So let‚Äôs do some work.

Suppose I open index.html
and I add a button:

<button>Submit</button>

This is my feature work.
Now I check the status:
git status

Git shows changes ‚Äî
and remember:

üëâ These changes belong to feature-button, not main.

-----

First Commit in Feature Branch

Now I stage and commit:

git add .
git commit -m "button added"

Git tells me:

1 file changed
2 insertions

This commit exists only in feature-button.
Main branch does not have this button.

-----

Multiple Commits in the Same Feature

Now let‚Äôs extend this.

I add another button in contact.html:

<button>Submit Contact</button>

Then:

git add .
git commit -m "contact button"

Now one more.

I update about.html:

<button>Submit About</button>

Then:

git add .
git commit -m "about submit button"


Now pause.

What did we do?

üëâ We made multiple small commits
üëâ All commits belong to feature-button
üëâ Main branch is still clean

-----

Viewing Commit History

Now if I run:

git log --oneline

You‚Äôll see something like:

about submit button
contact button
button added

older commits from main
This means:

üëâ Main branch stopped earlier
üëâ Feature branch moved ahead

----------------


So visually:

Main branch is here
Feature branch has 3 extra commits
Both branches are now different

-----

Pushing Feature Branch to GitHub

Now I don‚Äôt want this code only on my laptop.
So I push it.
But not to main.
I run:

git push origin feature-button

Now the feature branch is safely stored on GitHub.

If I refresh GitHub:
I‚Äôll see feature-button
I‚Äôll see all 3 commits

Main branch still remains unchanged.

-----

Switching Back to Main Branch

Now locally, I switch back:

git checkout main

Now observe carefully.
If I open my files:
Buttons are gone
Code looks old

Why?

Because main branch never had those commits.
Now if I switch back again:

git checkout feature-button

Buttons are back.

üëâ This proves branches are independent timelines.

-----

Merging Feature Branch into Main

Now suppose my feature is complete.

I want to merge it into main.
Step 1:
Go to the branch where you want the changes.
So I run:
git checkout main

Step 2:
Merge the feature branch:
git merge feature-button

Git now tells:
3 files changed
6 insertions

That means:

üëâ All feature commits are now part of main


-----

Pushing Merged Code

Now this merge is local only.

So I must push it:
git push origin main

Now GitHub main branch has:
all button changes
clean history

-----


Deleting Feature Branch (Cleanup)

Now the feature is done.

So we delete the branch.

Locally:
git branch -d feature-button
Now feature-button is gone locally.

To delete it from GitHub:
git push origin --delete feature-button

Now the branch is completely removed

-----

Why We Delete Branches

Because:

Feature is merged
Branch is no longer needed
Clean repository is important

In big companies:
Hundreds of branches exist
Old ones are deleted regularly

-----

Final Visual Recap

---------------------------------------

Working With Multiple Branches & Using git pull (Practical)

We already know how to create a branch,
we know how to commit,
and we know how to merge.

Now what I want to do is play with multiple branches,
because that is how Git is actually used in real projects.

So let‚Äôs practice a very realistic scenario.

Right now, we are at a point where everything is stable.
We have already committed our latest changes on the main branch.

So we are standing at a clean commit.

From here, I want to experiment with a new feature.

-----

Creating a New Branch for Search Feature

So I‚Äôm going to create a new branch.

This time, the feature is search.

For now, I‚Äôll just call the branch search.

Later in real projects, you can name it feature-search,
but for learning purposes, we‚Äôll keep it simple.

So I run:

git branch search

This creates the branch.

Now remember ‚Äî
creating a branch does NOT mean we are inside it.

So to verify, I run:
git branch

I can see both main and search.

The star is still on main.

Switching to the Search Branch

Now I want to work on the search feature.

So I switch to the branch:

git checkout search
Now Git confirms that I‚Äôm inside the search branch.

At this moment, whatever I do,
whatever I commit,
will belong only to the search branch.

------

Creating Search.html

Now inside this branch,
I‚Äôm going to create a new file called search.html.

I add some random HTML code inside it.

Everything looks good.

Now I check status,
stage the file,
and commit it.

git add .
git commit -m "created search page"

This commit is now part of the search branch only.

-----
Pushing Search Branch to GitHub

Now I want this branch to be available on GitHub as well.

So I push it:

git push origin search


Now when I refresh GitHub,
I can see a new branch called search.

If I open this branch,
I can see search.html.

If I switch to main on GitHub,
I won‚Äôt see that file.

This proves that branches are independent.

-----

Switching Back to Main Branch

Now locally, let me switch back to main:

git checkout main

Immediately, search.html disappears.

That‚Äôs expected.

Main branch never had that file.

-----

More Commits on Search Branch

Now I go back again:

git checkout search


Inside search.html,
I add an <h1> tag saying ‚ÄúSearch‚Äù.

Then I add a paragraph with some lorem text.

Now I commit again:

git add .
git commit -m "updated search page"
git push origin search

So now the search branch has two commits:
one for creating the page
one for updating it

Main branch still knows nothing about this.

-----

Now Something Important Happens

Now pay attention.

While I was working on the search branch,
someone ‚Äî maybe me, maybe a teammate ‚Äî
made a change in the main branch.

So I switch to main:

git checkout main

Inside index.html,
I add some new content ‚Äî maybe a paragraph.

Then I commit and push:

git add .
git commit -m "index update"
git push origin main


Now the main branch has new changes.

-----

Problem: Search Branch Is Outdated

Here is the important problem.

My search branch does not have this index update.

Because that update was done on main
while I was working separately.

So now:

main branch is ahead
search branch is behind

This is very common in team environments.

----

Getting Latest Main Changes Into Search Branch

Now I want all the latest changes from main
inside my search branch.

So first, I switch to search:

git checkout search

Now I pull changes from main:

git pull origin main

What does this do?
This command means:

‚ÄúTake everything from main branch
and bring it into my current branch.‚Äù

So now:

index updates come into search
no search changes are lost
Git merges them safely.

-----

Why We Pull Before Merging

This step is extremely important.

Before merging your feature branch into main,
you should always:

pull latest main changes
test everything together
make sure nothing breaks

This avoids surprises and conflicts.

-----

Merging Search Branch Into Main

Now everything looks good.

Search feature is ready.
Main branch updates are already included.

So now I merge.
First, I switch to main:

git checkout main

Then I merge search:

git merge search

Now:

search.html is added
search updates are merged
index update remains intact
Everything is combined.

-----

Pushing Final Changes

Now this merge is still local.

So I push it:

git push origin main

Now GitHub main branch has:
index update
search page

all changes together

-----

Deleting the Search Branch

Now the search feature is done.

We don‚Äôt need the branch anymore.

So first, delete it locally:
git branch -d search

Then delete it from GitHub:
git push origin --delete search

Now the repository is clean again.

Only main branch remains.

-----

Final Understanding

So let‚Äôs summarize what actually happened.

You worked on a feature branch.
Main branch changed in parallel.
You pulled main into your feature branch.
You tested everything together.
Then you merged the feature back into main.

This is real-world Git usage.

This is exactly how teams work.

--------

Understanding git pull in a Team Environment (Intentionally Creating a Problem)

I want to do this intentionally.

I want to create a problem on purpose,
so that you clearly understand why git pull is needed
and what problem it actually solves.

Right now, everything is working fine.

We are inside our main branch.
We have made commits locally.
We have pushed those commits to the remote repository.

So far, no issues.

-------

The Real-World Question

Now let me ask you something very important.

What if someone else also made a change?

When I say ‚Äúsomeone else,‚Äù it could be:

your teammate

or even you, editing files directly on GitHub

That change exists on the remote repository,
but not on your local machine.

Now think about this carefully.

------

What We Usually Do

Normally, our workflow looks like this:

we make some changes

we do git add
we do git commit
we do git push

Everything works fine.

We push again.
Works fine.

We push again.
Still fine.

But this works only when no one else is changing the code.

--------

Creating a Change Directly on GitHub

Now let‚Äôs intentionally create a problem.

Suppose I act like a teammate.

I go to GitHub directly.
I open index.html.
I edit it online.

Maybe I change some text.
Maybe I update the homepage content.

Then I click Commit.

Now what happened?

A new commit was created:
on the remote repository
on the main branch

But my local system does not know this yet.

------

Local Machine Is Now Outdated

Now come back to my local system.

I‚Äôm still working normally.

I don‚Äôt know that:
someone updated index.html
a new commit already exists on GitHub
So locally, I start working.

Maybe I add a paragraph.
Maybe I update the search page.

Everything looks fine locally.

---------

Trying to Push Without Pulling

Now I do what I always do.

I run:

git add
git commit
git push origin main

And now‚Ä¶
Git says NO.

Push fails.


------

Why Did Git Reject the Push?

Because Git detected something very important.

It noticed that:
the remote main branch has commits
that your local main branch does not have
And Git will never allow you to:
overwrite someone else‚Äôs work
or push blindly

This is Git protecting the codebase.

------

The Solution: git pull

So what should we do now?

We must first bring those remote changes to our local machine.
That‚Äôs where git pull comes into the picture.

So I run:
git pull origin main

Now read this carefully.

This command means:

‚ÄúTake everything from the remote main branch
and merge it into my local main branch.‚Äù

-----

What Happens Internally

Git now does two things:

It downloads the new commits from GitHub
It merges them with your local changes

Now both versions are in sync.

Your local machine finally knows:
what changed online
what was done by others

-----

Pushing Again (Now It Works)

Now I try again:

git push origin main

This time, it works.
Why?

Because now:

local main
remote main

both contain the same history.
-----

Understanding This Habit

This is why git pull is extremely important
when you work in a team.

Because imagine this situation:

Team member A pushes a change
Team member B pushes a change
Team member C pushes a change

Now when you want to push:

You should first get:

A‚Äôs changes
B‚Äôs changes
C‚Äôs changes

And then add your own.

Good Practice Rule

So the correct habit is:

Before pushing your code,
always pull first.

That way:

you avoid errors
you avoid conflicts
you stay updated
-----



