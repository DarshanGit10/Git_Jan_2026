Git Squash â€” Complete Teaching Script

Now in this session, we are going to talk about Git Squash.
Git squash is a technique that allows us to combine multiple commits into a single commit.
This is extremely useful when we want to keep our commit history clean and meaningful, especially before pushing code or raising a pull request.

Why Do We Need Squash?

While developing a feature, we usually make many small commits like:

small update
typo fix
minor change
final fix

These commits are fine while working,
but we donâ€™t want all of them permanently in our main branch history.

Thatâ€™s where Git Squash comes into the picture.
------
Practical Example Setup
git log --oneline 

do multiple commits 

Observing the Problem

Now letâ€™s check the commit history.

git log --oneline


Youâ€™ll notice that I have multiple commits related only to the index file.

If I push this now, GitHub will show 4 separate commits,
even though logically this is just one change.

I donâ€™t want that.

I want one clean commit called â€œupdated indexâ€.

----


Understanding HEAD (Very Important)

Before squashing, letâ€™s quickly understand HEAD.

HEAD â†’ current commit
HEAD~1 â†’ one commit before
HEAD~2 â†’ two commits before
HEAD~3 â†’ three commits before

So if I want to combine the last 4 commits,
Iâ€™ll use HEAD~4.

-----

Git squash is done using interactive rebase.

git rebase -i HEAD~4

or 

git rebase -i 08e20cf^


This opens an interactive editor.

Interactive Rebase Screen

Youâ€™ll see something like this:

pick a1b2c3 updated user
pick d4e5f6 updated index
pick g7h8i9 index updated again
pick j1k2l3 final index update

Explain Clearly ğŸ‘‡

pick â†’ keep the commit

s or squash â†’ combine this commit with the one above

------------


Squashing the Commits

I want to keep one commit and squash the rest.

So Iâ€™ll modify it like this:

pick a1b2c3 updated user
pick d4e5f6 updated index
s g7h8i9 index updated again
s j1k2l3 final index update


This means:

updated index stays
The next two commits are merged into it
Now save and exit the editor.

(Press ESC, type :wq, hit Enter)

------------

Final Commit Message

Git now asks me to confirm the final commit message.

Iâ€™ll keep:

updated index


Save and exit again.

âœ… Result Verification
git log --oneline


Now you can see:

updated user
updated index

All index-related commits are now combined into a single commit.

----

Push to Remote
git push origin main


When I refresh GitHub,
I can clearly see only two meaningful commits.

The updated index commit now contains all changes:

link added
updates done
final changes

Instead of three separate commits.

ğŸ¯ Key Takeaways (Say This Slowly)

Pick â†’ commit stays
Squash â†’ commit gets merged
Squash is used to clean history
Squash is usually done before merging or pushing

----------

Commit freely while working, squash before merging.
----------------------------



Git revert is used when we want to undo a commit safely,
without rewriting Git history.

This is extremely important when you are working on shared branches like main.

What is Git Revert?

Git Revert creates a new commit that reverses the changes made by an earlier commit.

ğŸ“Œ One-liner:

â€œRevert does not remove a commit â€” it adds a new commit that undoes it.â€


Practical Example Setup

git log --oneline
-------------

Reverting Using HEAD (Most Common Case)

When the last commit is wrong,
we donâ€™t even need the commit hash.

We can simply use HEAD.

Command:
git revert HEAD


Explain ğŸ‘‡

HEAD refers to the current/latest commit

This command reverts only the most recent commit

-------
Commit Message

Git opens an editor with a default message:

Revert "updated index"


This is auto-generated and completely fine.

Save and exit.

---------

Check the History
git log --oneline

everting an Older Commit Using HEAD~n

Now suppose the last commit is fine,
but a previous commit caused the issue.

We can still use HEAD.

Example:
git revert HEAD~1


Explain:

HEAD~1 â†’ one commit before HEAD

HEAD~2 â†’ two commits before HEAD

So this command reverts the second latest commit.

------------
using commit id 

git revert a1b2c3

-----------------


High-Level Difference (Say This First)

git restore works on FILES
git revert works on COMMITS

This one sentence already solves 80% of confusion.

What is git restore?

git restore is used to undo file-level changes
before they become part of a commit.

It is mainly used in:

Working directory

Staging area

ğŸ“Œ git restore does NOT create a commit.

-------

What is git revert?

git revert is used to undo a commit safely.

It:

Works on commits

Creates a new commit

Does not rewrite history

ğŸ“Œ git revert is safe for shared branches like main.

---------




----------


When to Use What? (Very Important)
âœ… Use git restore when:

Changes are not committed
You made a mistake in a file
You want to unstage a file

âœ… Use git revert when:

The change is already committed
The commit is pushed
Youâ€™re working in a team

-----------------------------------------------


Topic: Git Reset â€” Undoing Commits Locally

Git reset is a powerful command, but also a dangerous one if used incorrectly.

So today, weâ€™ll understand:

What git reset does
The different types of reset
When to use it
When NOT to use it

------


What is Git Reset? (Definition)

Git reset moves the HEAD pointer to a previous commit.

Depending on the type of reset, it can:

Undo commits
Unstage files
Remove file changes

ğŸ“Œ One-line definition:

â€œGit reset rewrites history by moving HEAD.â€

------------

Very Important Warning (Say This Slowly)

âŒ Do NOT use git reset on pushed commits
âŒ Do NOT use git reset on shared branches like main
âœ… Safe only for local, unpushed work

-------

Example Setup

First, let me check my commit history.

git log --oneline


Assume we have:

c3  final index update
c2  index updated
c1  updated user

--------

git reset --soft (Safest Reset)
ğŸ§  What It Does

Moves HEAD back
Keeps changes staged
Code is NOT lost

ğŸ§ª Scenario

I committed something by mistake,
but I want to edit the commit message or code.

Command:
git reset --soft HEAD~1


Explain:

Commit is removed
Files stay in staging area
Ready to recommit

Use Case

â€œI want to fix my last commit.â€

----------

git reset --mixed (Default Reset)
ğŸ§  What It Does

Moves HEAD back
Unstages files
Keeps changes in working directory

(Default mode if you donâ€™t specify anything)

ğŸ§ª Scenario

I committed too early,
I want to re-review my files.

Command:
git reset HEAD~1

or

git reset --mixed HEAD~1


Explain:

Commit removed
Files are unstaged
Code is still safe

Use Case
â€œI want to re-stage files properly.â€

----------


git reset --hard (ğŸ”¥ Dangerous)
ğŸ§  What It Does

Moves HEAD back
Deletes commit
Deletes file changes

âš ï¸ Code is permanently lost

ğŸ§ª Scenario

I made a commit and file changes,
and I want to completely discard everything.

Command:
git reset --hard HEAD~1


Explain:

Commit removed

Files removed

Working directory cleaned

âš ï¸ Warning (Say This Clearly)

âŒ If you use this on pushed code â†’ disaster
âŒ Use only when youâ€™re 100% sure

----------


| Reset Type | Commit    | Staging   | Working Directory |
| ---------- | --------- | --------- | ----------------- |
| --soft     | âŒ removed | âœ… kept    | âœ… kept            |
| --mixed    | âŒ removed | âŒ removed | âœ… kept            |
| --hard     | âŒ removed | âŒ removed | âŒ removed         |


git reset (Commit-Level Undo â€” Local)
ğŸ“Œ What it does

git reset moves HEAD backward and removes commits.

Rewrites history

Dangerous if misused

Should be used only locally

| Feature                   | git restore       | git reset                 | git revert             |
| ------------------------- | ----------------- | ------------------------- | ---------------------- |
| Works on                  | Files             | Commits (HEAD)            | Commits                |
| Creates commit            | âŒ No              | âŒ No                      | âœ… Yes                  |
| Rewrites history          | âŒ No              | âœ… Yes                     | âŒ No                   |
| Safe for pushed code      | âŒ No              | âŒ No                      | âœ… Yes                  |
| Used before commit        | âœ… Yes             | âŒ No                      | âŒ No                   |
| Used after commit         | âŒ No              | âœ… Yes (local)             | âœ… Yes                  |
| Affects working directory | âœ… Yes             | Depends (soft/mixed/hard) | âœ… Yes (via new commit) |
| Common use                | Undo file changes | Undo local commits        | Undo shared commits    |
| Typical branch            | Any               | Feature / local           | main / production      |


----------------------------------------

Git History & Debugging


Goal of This Session

By the end of this session, you should be able to answer:

Who changed this line?
When was this change made?
Which commit caused the issue?
How to recover a lost commit?
---------------------

git log --oneline --graph
ğŸ“Œ Read the Commit Timeline

First, let me look at the commit history.


Explain slowly ğŸ‘‡
--oneline â†’ short and readable commits
--graph â†’ shows branch structure visually

This helps us understand how the project evolved.


-----

Scenario: â€œWhich commit broke the app?â€

When something breaks, this is the first command you run.

You look at:

Recent commits

Merge points

Feature changes

2ï¸âƒ£ git show <commit>
ğŸ“Œ Inspect What Changed

Now letâ€™s inspect a specific commit.

git show a1b2c3


Explain ğŸ‘‡

This shows:

Files changed
Lines added
Lines removed
Commit message
Author & date

Scenario: â€œWhat exactly changed here?â€

Instead of guessing,
we see the exact diff.

This helps in:

Debugging bugs
Code reviews
Understanding old code

----------


git blame <file>
ğŸ“Œ Find Who Changed a Line

Now letâ€™s answer one of the most common questions in software teams.

git blame index.html


Explain ğŸ‘‡

For every line, Git shows:

Commit ID
Author
Timestamp
This tells us who last modified each line.

Scenario: â€œWho changed this line?â€

This is NOT about blaming people ğŸ˜„
Itâ€™s about:

Asking the right person

Understanding the reason behind the change


----------

git reflog ğŸ”¥
ğŸ“Œ Recover Lost Commits (Life Saver)

Now letâ€™s talk about one of the most powerful Git commands.

git reflog


Explain clearly ğŸ‘‡

git reflog shows:
Every movement of HEAD
Resets
Rebases

Checkouts

Even commits that disappear from git log appear here.

ğŸ§ª Scenario: â€œMy commit is missing!â€

This usually happens after:

git reset
git rebase
Mistaken checkout

But donâ€™t panic.
git reflog

---------------------

Introducing .gitignore

Git provides a special file for this purpose.

That file is called:

.gitignore

This name is fixed.

You cannot rename it.
You cannot change it.

Git specifically looks for a file named .gitignore.


How .gitignore Works

Inside the .gitignore file,
you simply write the names of files or folders
that you want Git to ignore.

For example, if I write:

.env


That means:

Git will ignore the .env file
.env will remain untracked forever

Even if the file exists on my system,
Git will act as if it doesnâ€™t matter.

----

Important Point About .gitignore

Now pay attention to this.

The .gitignore file itself is tracked.

That means:

.gitignore goes to staging
.gitignore gets committed
.gitignore is pushed to GitHub

Why?

Because we want everyone in the team
to follow the same ignore rules.

--------

What Happens to Ignored Files

Files mentioned inside .gitignore:

stay in the working directory
remain untracked
never move to staging
never reach GitHub

Git completely ignores them

-----

Checking Git Status

If I run:

git status

Youâ€™ll notice something interesting.

Git shows:
.gitignore as untracked (initially)

but does NOT show ignored files

Thatâ€™s how you know ignoring is working.

-----

Committing .gitignore

Now I add and commit the .gitignore file.

I do:

git add .gitignore
git commit -m "added gitignore"
git push origin main


Now .gitignore is part of the repository.

-----

Why .gitignore Is Very Important

Using .gitignore helps you:

protect sensitive data
keep repository clean
avoid pushing unnecessary files
follow professional practices

Every real-world project uses .gitignore


----------------------------

So far, weâ€™ve mostly created repositories locally.
But in real-world projects, we almost always start with existing code on GitHub.

Thatâ€™s where git clone comes in.

ğŸ§  What is Git Clone? (Definition)

git clone is used to create a local copy of a remote repository.

It:

Downloads the entire project
Includes full commit history
Automatically connects to the remote repository

ğŸ“Œ One-line definition:

â€œClone copies a remote repository to your local machine.â€

Why Do We Need git clone?

Imagine joining a company or a project.

You donâ€™t write code from scratch.
You clone the repository and start working.

-----------

After Cloning

Let me move into the project folder.

cd repository-name


Now if I check:

git status


Youâ€™ll see:

â€œOn branch mainâ€
â€œWorking tree cleanâ€

Meaning:

You are connected to Git

You are ready to work

------------


Scenario: Clone vs Download ZIP

Ask students ğŸ‘‡

Why not just download ZIP?

Explain:

ZIP âŒ No Git history
ZIP âŒ No commits
ZIP âŒ No push/pull

Clone âœ… Full Git power

-------

Fork â€” Contributing Without Direct Access
ğŸ¤ Introduction

Hey there.
Welcome back.

So far, weâ€™ve learned how to clone repositories, create branches, and work with commits.
Now weâ€™re going to talk about something that exists only on GitHub â€” Fork.

Fork is extremely important if you want to contribute to open-source projects or repositories where you donâ€™t have write access.

ğŸ§  What is a Fork? (Definition)
A Fork is a copy of someone elseâ€™s repository created on your own GitHub account.

ğŸ“Œ One-line definition:
â€œFork creates your own GitHub copy of a repository so you can work independently.â€


----

Why Do We Need Fork?

Ask students ğŸ‘‡

What if you want to contribute to a project,
but you cannot push directly to that repository?

For example:

Open-source projects
Someone elseâ€™s public repo
Company repo where you donâ€™t have access

ğŸ‘‰ You fork it.

----

